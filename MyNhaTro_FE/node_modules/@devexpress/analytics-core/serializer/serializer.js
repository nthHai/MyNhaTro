/**
* DevExpress Analytics (serializer\serializer.js)
* Version:  22.2.14
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { extend, isPlainObject, isEmptyObject } from './_utils';
import { serializeDate } from './utils';
export class ModelSerializer {
    constructor(options) {
        this._refTable = {};
        this._linkTable = {};
        this._options = extend({
            useRefs: true,
            serializeDate: serializeDate
        }, options);
    }
    linkObjects() {
        Object.keys(this._linkTable).forEach((index) => {
            var val = this._refTable[index];
            if (val) {
                this._linkTable[index].splice(0).forEach(property => property(val));
            }
        });
    }
    _getModel(model, propertyPath) {
        var currentModel = model;
        propertyPath.forEach((name) => {
            currentModel = currentModel[name];
        });
        return currentModel;
    }
    _collectLinks(model, internalModel, propertyPath, propertyName) {
        var refVal = model[propertyName].slice('#Ref-'.length);
        var value = ko.observable();
        this._linkTable[refVal] = this._linkTable[refVal] || [];
        this._linkTable[refVal].push(value);
        if (!internalModel._restoreLinks)
            internalModel._restoreLinks = [];
        internalModel._restoreLinks.push((model) => {
            var currentModel = this._getModel(model, propertyPath);
            return {
                setRef: (ref) => {
                    if (ref === -1)
                        delete currentModel[propertyName];
                    else
                        currentModel[propertyName] = '#Ref-' + ref;
                },
                obj: value()
            };
        });
    }
    _enumRefs(internalModel, propertyPath, propertyName) {
        if (!internalModel._refs)
            internalModel._refs = [];
        internalModel._refs.push((model, ref) => {
            this._getModel(model, propertyPath)[propertyName] = ref;
        });
    }
    _collectLinksAndEnumRefs(model, internalModel = null, propertyPath = []) {
        var start = internalModel === null;
        internalModel = internalModel || model;
        Object.keys(model).forEach((propertyName) => {
            if (model[propertyName] instanceof Object) {
                this._collectLinksAndEnumRefs(model[propertyName], internalModel, [].concat(propertyPath, [propertyName]));
            }
            else if (model[propertyName].indexOf && model[propertyName].indexOf('#Ref-') === 0) {
                this._collectLinks(model, internalModel, propertyPath, propertyName);
            }
            else if (!start && propertyName === '@Ref') {
                this._enumRefs(internalModel, propertyPath, propertyName);
            }
        });
        if (start)
            this.linkObjects();
    }
    setLinks(refs) {
        refs.linkObjTable.forEach(item => {
            var refValue = refs.objects.indexOf(item.obj);
            item.setRef(refValue);
        });
    }
    deserializeProperty(modelPropertyInfo, model) {
        var propName = modelPropertyInfo.modelName;
        if (!propName) {
            return;
        }
        var modelValue = model[propName] !== undefined ? model[propName] : modelPropertyInfo.defaultVal;
        return this.deserializePropertyValue(modelPropertyInfo, modelValue);
    }
    deserializeDefaultValue(modelPropertyInfo) {
        var value = this.deserializePropertyValue(modelPropertyInfo, modelPropertyInfo.defaultVal, false);
        return value || modelPropertyInfo.defaultVal;
    }
    deserializePropertyValue(modelPropertyInfo, modelValue, strict = true) {
        if (typeof modelPropertyInfo === 'string') {
            return ko.observable(modelValue);
        }
        else if (modelPropertyInfo.link) {
            var value = ko.observable(null);
            if (modelValue) {
                var refVal = modelValue && modelValue.slice('#Ref-'.length);
                this._linkTable[refVal] = this._linkTable[refVal] || [];
                this._linkTable[refVal].push(value);
            }
            return value;
        }
        else if (modelPropertyInfo.array) {
            if (modelPropertyInfo.from) {
                return modelPropertyInfo.from(modelValue, this);
            }
            else if (modelPropertyInfo.info) {
                var result = Object.keys(modelValue || {}).map(propertyName => {
                    var object = { getInfo: () => { return modelPropertyInfo.info; } };
                    this.deserialize(object, modelValue[propertyName] || {});
                    return object;
                });
                return ko.observableArray(result);
            }
            return;
        }
        else if (modelPropertyInfo.from) {
            return modelPropertyInfo.from(modelValue, this);
        }
        else if (modelPropertyInfo.type) {
            var ctorResult = new modelPropertyInfo.type(modelValue, this, modelPropertyInfo.info);
            if (!ctorResult._model) {
                this.deserialize(ctorResult, modelValue || {}, modelPropertyInfo.info);
            }
            return ctorResult;
        }
        else if (modelPropertyInfo.info) {
            var object = { getInfo: () => { return modelPropertyInfo.info; } };
            this.deserialize(object, modelValue || {});
            return object;
        }
        else if (modelPropertyInfo.modelName) {
            return ko.observable(modelValue);
        }
        if (strict) {
            throw new Error("Invalid info '" + JSON.stringify(modelPropertyInfo) + "'");
        }
        return;
    }
    deserialize(viewModel, model, serializationsInfo = null) {
        if (!model) {
            return;
        }
        viewModel._model = extend({}, model);
        var _serializationsInfo = viewModel.getInfo ? viewModel.getInfo() : serializationsInfo;
        var refValue = model['@Ref'];
        var proto = Object.getPrototypeOf(viewModel);
        _serializationsInfo.forEach((modelPropertyInfo) => {
            var propertyName = modelPropertyInfo.propertyName, propName = modelPropertyInfo.modelName;
            if (model[propName] !== undefined) {
                delete viewModel._model[propName];
            }
            var property = this.deserializeProperty(modelPropertyInfo, model);
            var descriptor = Object.getOwnPropertyDescriptor(proto, propertyName);
            if (property !== undefined && (!descriptor || !!descriptor.set))
                viewModel[propertyName] = property;
            if (!(propertyName in viewModel) && property === undefined && modelPropertyInfo.array) {
                var currentArray = ko.observable(undefined);
                Object.defineProperty(viewModel, propertyName, {
                    get: () => {
                        return currentArray();
                    },
                    set: (val) => {
                        currentArray(val);
                    },
                    enumerable: true,
                    configurable: true
                });
            }
        });
        if (refValue) {
            this._refTable[refValue] = viewModel;
        }
        this.linkObjects();
    }
    serialize(viewModel, serializationsInfo, refs = null) {
        if (!serializationsInfo && !refs) {
            return this._serialize(viewModel, null, null);
        }
        return this._serialize(viewModel, serializationsInfo, refs);
    }
    _isSerializableValue(resultValue) {
        return (isPlainObject(resultValue) && !isEmptyObject(resultValue)) || (Array.isArray(resultValue) && resultValue['length'] > 0) || (!Array.isArray(resultValue) && !isPlainObject(resultValue));
    }
    serializeProperty(modelPropertyInfo, viewModel, serializationsInfo, refs, result) {
        var propertyName = modelPropertyInfo.propertyName, value = ko.unwrap(viewModel['_' + propertyName] || viewModel[propertyName]), defaultVal = modelPropertyInfo.defaultVal;
        if (modelPropertyInfo.beforeSerialize)
            value = modelPropertyInfo.beforeSerialize(value);
        if (!!modelPropertyInfo.from) {
            defaultVal = ko.unwrap(modelPropertyInfo.from(defaultVal, this));
        }
        var resultValue = {};
        if (!modelPropertyInfo.modelName) {
            return;
        }
        if (modelPropertyInfo.alwaysSerialize || ((value !== undefined && value !== null) && ((isPlainObject(value) || !isEmptyObject(value)) || (Array.isArray(value) && value.length > 0) || (!Array.isArray(value) && !isPlainObject(value))) && (value !== defaultVal))) {
            if (modelPropertyInfo.link) {
                refs.linkObjTable.push({
                    obj: value,
                    setRef: (index) => {
                        if (index < 0) {
                            delete result[modelPropertyInfo.modelName];
                        }
                        else {
                            result[modelPropertyInfo.modelName] = '#Ref-' + index;
                        }
                    }
                });
                resultValue = undefined;
            }
            else if (modelPropertyInfo.array) {
                resultValue = {};
                var index = 1;
                value.forEach(item => {
                    var info = modelPropertyInfo.info || null;
                    var item_ = this._serialize(item, info, refs);
                    if (this._isSerializableValue(item_) || modelPropertyInfo.alwaysSerialize) {
                        resultValue['Item' + index] = item_;
                        if (this._options.useRefs) {
                            item_['@Ref'] = (refs.objects.push(item) - 1).toString();
                        }
                        index++;
                    }
                });
            }
            else if (modelPropertyInfo.from) {
                if (value['isEmpty'] && value['isEmpty']()) {
                    resultValue = {};
                }
                else {
                    resultValue = modelPropertyInfo.toJsonObject ? modelPropertyInfo.toJsonObject(value, this, refs) : value.toString();
                }
            }
            else if (modelPropertyInfo.info || value['getInfo']) {
                resultValue = this._serialize(value, modelPropertyInfo.info, refs);
            }
            else if (modelPropertyInfo.modelName) {
                if (value instanceof Date) {
                    resultValue = this._options.serializeDate(value);
                }
                else {
                    resultValue = value;
                }
            }
            else {
                throw new Error("Invalid info '" + serializationsInfo.stringify() + "'");
            }
            if (modelPropertyInfo.alwaysSerialize || this._isSerializableValue(resultValue)) {
                if (modelPropertyInfo.asRef) {
                    resultValue['@Ref'] = (refs.objects.push(value) - 1).toString();
                }
                result[modelPropertyInfo.modelName] = resultValue;
            }
        }
    }
    _serialize(viewModel, serializationsInfo, refs) {
        var result = extend(true, {}, viewModel._model), isInitial = refs === null;
        refs = refs || { linkObjTable: [], objects: [] };
        if (result._restoreLinks) {
            refs.linkObjTable.push.apply(refs.linkObjTable, result._restoreLinks.map(x => x(result)));
            delete result._restoreLinks;
        }
        if (result._refs) {
            result._refs.forEach(x => x(result, (refs.objects.push('0') - 1).toString()));
            delete result._refs;
        }
        serializationsInfo = viewModel.getInfo ? viewModel.getInfo() : serializationsInfo;
        delete result['@Ref'];
        if (viewModel['isEmpty'] && viewModel['isEmpty']())
            return {};
        serializationsInfo.forEach((modelPropertyInfo) => {
            this.serializeProperty(modelPropertyInfo, viewModel, serializationsInfo, refs, result);
        });
        if (isInitial)
            this.setLinks(refs);
        return result;
    }
}

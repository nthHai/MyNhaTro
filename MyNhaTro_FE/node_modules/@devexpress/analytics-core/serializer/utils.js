/**
* DevExpress Analytics (serializer\utils.js)
* Version:  22.2.14
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
export class Disposable {
    constructor() {
        this._disposables = [];
        this.isDisposing = false;
    }
    disposeObservableArray(array) {
        if (array) {
            array().forEach((item) => { item.dispose && item.dispose(); });
        }
    }
    resetObservableArray(array) {
        if (array)
            array([]);
    }
    disposeArray(array) {
        if (array) {
            array.forEach((item) => { item.dispose && item.dispose(); });
            array.splice(0, array.length);
        }
    }
    addDisposable(...disposables) {
        this._disposables.push(...disposables.map(x => {
            if (!x)
                return x;
            if ('dispose' in x)
                return x;
            else {
                return { dispose: x };
            }
        }));
    }
    dispose() {
        if (!this.isDisposing) {
            this.isDisposing = true;
            (this._disposables || []).reverse().forEach(x => x && x.dispose && x.dispose());
            this._disposables = [];
        }
    }
    removeProperties() {
        Object.keys(this).forEach((propertyName) => {
            delete this[propertyName];
        });
    }
}
export function deserializeArray(model, creator) {
    var result = Object.keys(model || {}).map(propertyName => creator(model[propertyName]));
    return ko.observableArray(result);
}
function toStringWithDelimiter(values, delimiter) {
    return (values || []).map(value => {
        var str = value !== undefined && value !== null ? value.toString() : '00';
        if (str.length === 1) {
            str = '0' + str;
        }
        return str;
    }).join(delimiter);
}
export function serializeDate(date, dateDelimiter) {
    var datePart = [date.getMonth() + 1, date.getDate(), date.getFullYear()];
    var timePart = toStringWithDelimiter([date.getHours(), date.getMinutes(), date.getSeconds()], ':');
    if (dateDelimiter === '-' || timePart === '00:00:00') {
        var datePartString = toStringWithDelimiter([datePart[2], datePart[0], datePart[1]], '-');
        return timePart === '00:00:00' ? datePartString : datePartString + ' ' + timePart;
    }
    return timePart === '00:00:00' ? toStringWithDelimiter([datePart[2], datePart[0], datePart[1]], '-')
        : toStringWithDelimiter(datePart, '/') + ' ' + timePart;
}
export function deserializeDate(dateTime) {
    var dateTimeParts = dateTime.split(' ');
    var dateArgs = dateTimeParts[0].split('-');
    var timeArgs = [0, 0, 0];
    if (dateTimeParts.length > 1) {
        if (dateArgs.length !== 3) {
            dateArgs = dateTimeParts[0].split('/');
            dateArgs.splice(0, 0, dateArgs.splice(2, 1)[0]);
        }
        timeArgs = dateTimeParts[1].split(':').map(x => parseInt(x));
        if (timeArgs.length !== 3)
            return null;
    }
    if (dateArgs.length !== 3)
        return null;
    dateArgs = dateArgs.map(x => parseInt(x));
    return new Date(dateArgs[0], dateArgs[1] - 1, dateArgs[2], timeArgs[0], timeArgs[1], timeArgs[2]);
}

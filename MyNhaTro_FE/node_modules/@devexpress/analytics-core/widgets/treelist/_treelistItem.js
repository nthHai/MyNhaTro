/**
* DevExpress Analytics (widgets\treelist\_treelistItem.js)
* Version:  22.2.14
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as $ from 'jquery';
import * as ko from 'knockout';
import { CodeResolver } from '../../property-grid/internal/_codeResolver';
import { getLocalization } from '../../property-grid/localization/localization_utils';
import { SvgTemplatesEngine } from '../../property-grid/widgets/internal/_svgTemplateEngine';
import { Disposable } from '../../serializer/utils';
import { createGlobalModuleVariableFunc } from '../../serializer/_internal';
import { PathRequest } from '../common/pathRequest';
import { LoadChildItemsForCollapsedNodes } from './options';
export var maxSearchLevel = createGlobalModuleVariableFunc(5);
export var treeListEditAction = {
    templateName: 'dx-treelist-edit-action',
    imageClassName: '',
    text: 'Edit',
    clickAction: $.noop,
    displayText: () => getLocalization('Edit', 'AnalyticsCoreStringId.Group_Edit')
};
export class DefaultTreeListItemFactory {
    createRootItem(options, path, onItemsVisibilityChanged, rtl) {
        return new TreeListRootItemViewModel(options, path, onItemsVisibilityChanged, rtl);
    }
    createItem(options, path, onItemsVisibilityChanged, rtl, resolver) {
        return new TreeListItemViewModel(options, path, onItemsVisibilityChanged, rtl, resolver);
    }
}
export class TreeListEllipsisButton {
    constructor(_availableItemsCount, padding, pageSize) {
        this._availableItemsCount = _availableItemsCount;
        this.padding = padding;
        this.pageSize = pageSize;
        this.templateName = 'dx-treelist-item-ellipsis';
        this.collapsed = () => true;
        this.visibleItems = () => [];
        this.text = () => getLocalization('Show more...', 'AnalyticsCoreStringId.QueryBuilder_Tables_ShowMore');
    }
    renderNext() {
        this._availableItemsCount(this._availableItemsCount() + this.pageSize);
    }
}
export class TreeListItemViewModel extends Disposable {
    constructor(options, path = [], onItemsVisibilityChanged = $.noop, rtl = false, resolver = new CodeResolver()) {
        super();
        this.resolver = resolver;
        this._rtl = false;
        this._data = ko.observable(null);
        this._actions = ko.observable([]);
        this._isVisible = ko.observable(true);
        this._pageSize = -1;
        this._walkCallback = null;
        this._isLoaded = ko.observable(false);
        this._actionsSubscription = null;
        this._subscriptions = [];
        this._visibleItemsCount = ko.observable(0);
        this._iconName = () => (ko.unwrap((this.data && this.data.icon) || (this.data && this.data.specifics)) || 'default').split('.').join('_').toLowerCase();
        this._nodeIsLocked = false;
        this.level = -1;
        this.items = ko.observableArray();
        this.collapsed = ko.observable(true);
        this.isSelected = ko.observable(false);
        this.isHovered = ko.observable(false);
        this.isMultiSelected = ko.observable(false);
        this.templates = {
            accordionItem: 'dx-treelist-accordion-item',
            headerItem: 'dx-treelist-header-item',
            headerItemContent: 'dx-treelist-header-item-caption-content',
            itemTextContent: 'dx-treelist-item-text-content',
            actionsContainer: 'dx-treelist-item-actions-container',
        };
        this._pageSize = options.pageSize || -1;
        this._path = path;
        this._rtl = rtl;
        if ('loadChildItemsForCollapsedNodes' in options)
            this._loadChildItemsForCollapsedNodes = options.loadChildItemsForCollapsedNodes;
        this._factory = options.factory || new DefaultTreeListItemFactory();
        this._treeListController = options.treeListController;
        this._templateName = options.templateName;
        this._onItemsVisibilityChanged = onItemsVisibilityChanged;
        this.dragDropHandler = options.treeListController.dragDropHandler;
        this._onItemsChangedCallback = options.onItemsChanged;
        this._visible = ko.computed(() => {
            if (this.data && this._treeListController.itemsFilter && !this._treeListController.itemsFilter(this.data, this.path, this))
                return false;
            return this._isVisible();
        });
        this.getItems = () => {
            if (this.items().length > 0)
                return $.Deferred().resolve(this.items()).promise();
            return this._loadItems(options);
        };
        this._initPaginate();
        this.toggleSelected = (_, event) => {
            if (event && (event.shiftKey || event.ctrlKey || event.metaKey) && this.selectedItems().length > 0 && this._treeListController.canMultiSelect && this._treeListController.canMultiSelect(this)) {
                options.selectedPath('');
                this._treeListController.multiSelect(this, event.shiftKey, event.ctrlKey || event.metaKey);
            }
            else if (this._treeListController.canSelect(this)) {
                options.treeListController.clickHandler && options.treeListController.clickHandler(this);
                options.selectedPath(this.path);
            }
        };
        if (options.treeListController.dblClickHandler) {
            this.dblClickHandler = (item) => {
                options.treeListController.dblClickHandler && options.treeListController.dblClickHandler(item);
            };
        }
        this.toggleCollapsed = () => {
            if (this.hasItems) {
                this.collapsed(!this.collapsed.peek());
                if (!this.collapsed.peek() && this.items().length === 0) {
                    this._loadItems(options, this._getLoadChildItemsForCollapsedNodes()).always(() => { onItemsVisibilityChanged(); });
                }
                else if (this._getLoadChildItemsForCollapsedNodes()) {
                    this.items().forEach((item) => {
                        item._treeListController.hasItems(item.data) && item.items().length === 0 && item._loadItems(options);
                    });
                    onItemsVisibilityChanged();
                }
            }
        };
        this.nodeImageClass = this._getNodeImageClassName();
        this._subscriptions.push(this._visible.subscribe((newValue) => this._updataParentItemsVisibilityCount(newValue)));
    }
    _equal(obj1, obj2) {
        var ignore = ['innerActions', 'noDragable', 'dragData'];
        if (obj2 === obj1)
            return true;
        return Object.keys(obj2).filter(key => ignore.indexOf(key) === -1).every((key) => {
            return obj2[key] === obj1[key];
        });
    }
    _getImageClassName(showIcon) {
        return ko.computed(() => {
            return 'dx-image-fieldlist-'
                + this._iconName()
                + (!showIcon ? ' dx-treelist-image-empty' : '');
        });
    }
    _getImageTemplateName() {
        return ko.computed(() => {
            var _templateName = 'dxrd-svg-fieldlist-' + this._iconName();
            return SvgTemplatesEngine.getExistingTemplate(_templateName);
        });
    }
    _getNodeImageClassName() {
        return ko.computed({
            read: () => {
                var result = 'dx-collapsing-image';
                if (!this.hasItems) {
                    return 'dx-image-leaf-node';
                }
                if (!this.collapsed())
                    result += ' dx-image-expanded';
                return result;
            }
        });
    }
    _createItemsObj(items) {
        var obj = {};
        for (var i = 0; i < items.length; i++) {
            obj[items[i].name] = { item: items[i], index: i };
        }
        return obj;
    }
    _loadItems(options, loadInnerItems = false) {
        var deferred = $.Deferred();
        if (this._loader) {
            this._loader.dispose();
        }
        this._disposables.reverse().forEach(x => x.dispose && x.dispose());
        this._disposables.splice(0);
        var promise = ko.observable();
        var subscription = promise.subscribe((value) => {
            if (!value)
                return;
            value.done((data) => {
                if (this.isDisposing) {
                    deferred.reject();
                    return;
                }
                this._isLoaded(true);
                var _data = data;
                var items = this.items.peek();
                var dataObj = this._createItemsObj(_data);
                var isMutated = false;
                var splicedItems = 0;
                var tempItems = [].concat.apply([], items);
                for (var i = 0; i < tempItems.length; i++) {
                    if (!dataObj[tempItems[i].data.name]) {
                        tempItems[i].dispose();
                        items.splice(i - splicedItems, 1);
                        splicedItems++;
                        isMutated = true;
                    }
                }
                this._visibleItemsCount(this._visibleItemsCount() - splicedItems);
                var itemsObj = this._createItemsObj(items);
                var resorted = false;
                var showIconsForChildItems = !this._treeListController.showIconsForChildItems || this._treeListController.showIconsForChildItems(this);
                var showIconTemplate = this._treeListController.showIconsForChildItems && this._treeListController.showIconsForChildItems(this);
                var visibleItemsCount = this._visibleItemsCount();
                _data.forEach((d, index) => {
                    var currentItem = itemsObj[d.name];
                    if (!currentItem) {
                        isMutated = true;
                        var newItem = this._factory.createItem(options, this.pathParts, this._onItemsVisibilityChanged, this._rtl, this.resolver);
                        newItem.data = d;
                        newItem.level = this.level + 1;
                        newItem.parent = this;
                        newItem.visible && (visibleItemsCount += 1);
                        newItem.padding = this._applyPadding(this._rtl ? 'right' : 'left', 20 * newItem.level + 12);
                        newItem.imageClassName = newItem._getImageClassName(showIconsForChildItems);
                        newItem.imageTemplateName = newItem._getImageTemplateName();
                        newItem.showIcon = showIconTemplate;
                        items.splice(index, 0, newItem);
                        itemsObj[d.name] = { item: newItem, index: index };
                        this._walkCallback && this._walkCallback(newItem);
                    }
                    else {
                        if (!this._equal(d, currentItem.item.data))
                            currentItem.item.data = d;
                        if (!resorted)
                            resorted = currentItem.index !== index;
                    }
                });
                this._visibleItemsCount(visibleItemsCount);
                this._walkCallback = null;
                if (resorted) {
                    var index = items.reduce((acc, x, index) => {
                        var max = Math.abs(index - (dataObj[x.data.name] ? dataObj[x.data.name].index : -1));
                        if (!acc || acc.max < max) {
                            return { max, index };
                        }
                        return acc;
                    }, null).index;
                    var curItem = items[index];
                    items.splice(index, 1);
                    items.splice(dataObj[curItem.data.name] ? dataObj[curItem.data.name].index : -1, 0, curItem);
                    isMutated = true;
                }
                dataObj = null;
                itemsObj = null;
                if (isMutated) {
                    this.items.valueHasMutated();
                    this._onItemsChanged();
                }
                if (!this.collapsed() || loadInnerItems) {
                    var condition = (item) => item._treeListController.hasItems(item.data);
                    if (this._loadChildItemsForCollapsedNodes !== undefined)
                        condition = (item) => (!item.collapsed() || loadInnerItems) && item._treeListController.hasItems(item.data);
                    this.items().forEach(item => {
                        if (condition(item)) {
                            item._loadItems(options);
                        }
                    });
                }
                deferred.resolve(this.items.peek());
                var selectedPath = options.selectedPath.peek();
                if (selectedPath) {
                    var item2Select = this.items.peek().filter(item => { return selectedPath.indexOf(item.path) === 0; })[0];
                    if (item2Select) {
                        this._selectItem(item2Select.name + selectedPath.substring(item2Select.path.length));
                    }
                }
            });
        });
        this._disposables.push({
            dispose: () => {
                subscription.dispose();
                promise(null);
            }
        });
        this._disposables.push(this._loader = ko.computed(() => {
            promise(options.itemsProvider.getItems(new PathRequest(this.path, this.pathParts)));
        }));
        return deferred.promise();
    }
    _onItemsChanged() {
        if (this._onItemsChangedCallback)
            this._onItemsChangedCallback(this.items());
    }
    _getTemplateName() {
        return this._templateName || this.data && this.data.templateName || 'dx-treelist-item';
    }
    _selectItem(itemPath) {
        if (!this.hasItems) {
            return;
        }
        var selectItemDelegate = () => {
            this._find(itemPath);
            if (this.collapsed.peek()) {
                this.toggleCollapsed();
            }
        };
        if (this.items.peek().length === 0) {
            this.getItems().done((items) => {
                selectItemDelegate();
            });
        }
        else {
            selectItemDelegate();
        }
    }
    _find(itemPath) {
        var item = itemPath && this.items.peek().filter(childItem => itemPath === childItem.name
            || itemPath.indexOf(childItem.name) === 0 && itemPath[childItem.name.length] === '.')[0];
        if (item) {
            if (itemPath.length > item.name.length) {
                item._selectItem(itemPath.substr(item.name.length + 1));
            }
            else {
                this._treeListController.select(item);
            }
        }
    }
    _getItemsWithLock() {
        var deffered = $.Deferred();
        if (this._nodeIsLocked)
            return deffered.reject().promise();
        this._nodeIsLocked = true;
        this.getItems().done(result => {
            this._nodeIsLocked = false;
            deffered.resolve(result);
        }).fail(() => {
            this._nodeIsLocked = false;
            deffered.reject();
        });
        return deffered.promise();
    }
    _applyPadding(position, value) {
        var padding = {};
        padding['padding-' + position] = value;
        return padding;
    }
    _getLoadChildItemsForCollapsedNodes() {
        return this._loadChildItemsForCollapsedNodes !== undefined ?
            this._loadChildItemsForCollapsedNodes : LoadChildItemsForCollapsedNodes();
    }
    _initPaginate() {
        if (this._pageSize === -1)
            return;
        this.maxItemsCount = ko.observable(this._pageSize);
        this.visibleItems = ko.computed(() => {
            if (this.items().length === 0)
                return [];
            var result = this.items().filter(x => x._isVisible.peek());
            if (result.length > this.maxItemsCount()) {
                result = result.slice(0, this.maxItemsCount());
                result.push(new TreeListEllipsisButton(this.maxItemsCount, result[0].padding, this._pageSize));
            }
            return result;
        });
    }
    _updataParentItemsVisibilityCount(visible) {
        var _a, _b;
        visible ? (_a = this.parent) === null || _a === void 0 ? void 0 : _a._visibleItemsCount(this.parent._visibleItemsCount() + 1)
            : (_b = this.parent) === null || _b === void 0 ? void 0 : _b._visibleItemsCount(Math.max(this.parent._visibleItemsCount() - 1, 0));
    }
    get hasItems() {
        if (!this.data) {
            return true;
        }
        var hasItems = this._treeListController.hasItems(this.data);
        if (this._loadChildItemsForCollapsedNodes != undefined) {
            return this._isLoaded() ?
                hasItems && this._visibleItemsCount() > 0 :
                hasItems;
        }
        return LoadChildItemsForCollapsedNodes() ?
            hasItems && this._visibleItemsCount() > 0 :
            hasItems;
    }
    get data() {
        return this._data();
    }
    set data(newVal) {
        this._data(newVal);
        this._actionsSubscription && this._actionsSubscription.dispose();
        this._actionsSubscription = ko.computed(() => {
            this._actions(this._treeListController && this._treeListController.getActions ? this._treeListController.getActions(this) : []);
        });
    }
    get name() {
        return ko.unwrap(this.data && this.data.name);
    }
    get path() {
        return this.pathParts.join('.');
    }
    get pathParts() {
        if (this.name) {
            return (ko.unwrap(this._path) || []).concat([this.name]);
        }
        else {
            return ko.unwrap(this._path);
        }
    }
    get text() {
        return this.data && this.data.displayName;
    }
    get templateName() {
        return this._getTemplateName();
    }
    actionsTemplate() {
        return this.data && ko.unwrap(this.data['actionsTemplate']) || 'dx-treelist-item-actions-with-edit';
    }
    treeListEditAction() {
        return treeListEditAction;
    }
    get hasContent() {
        return this.data && this.data['contenttemplate'];
    }
    get actions() {
        return this._actions();
    }
    get isDraggable() {
        if (this.data && this.data['dragData']) {
            return !this.data['dragData'].noDragable;
        }
        if (this._treeListController.isDraggable) {
            return this._treeListController.isDraggable(this);
        }
        return false;
    }
    get treeListController() {
        return this._treeListController;
    }
    dispose() {
        super.dispose();
        this._actions([]);
        this.visibleItems && this.visibleItems.dispose();
        this._actionsSubscription && this._actionsSubscription.dispose();
        this.disposeObservableArray(this.items);
        this.resetObservableArray(this.items);
        this._visibleItemsCount(0);
        this.parent = null;
        this._subscriptions.forEach(x => x.dispose());
        this._walkCallback = null;
        this._visible.dispose();
    }
    get visible() {
        return this._visible();
    }
    setVisible(value) {
        this._isVisible(value);
        if (value && this.parent && !this.parent.visible)
            this.parent.setVisible(true);
    }
    getCssRules() {
        return {
            'dx-treelist-item-selected dxd-state-selected': this.isSelected() || this.isMultiSelected()
        };
    }
    mouseenter() {
        this.isHovered(true);
    }
    mouseleave() {
        this.isHovered(false);
    }
    selectedItems() {
        return this._treeListController.selectedItems && this._treeListController.selectedItems() || [];
    }
}
export class TreeListRootItemViewModel extends TreeListItemViewModel {
    constructor(_options, path = [], onItemsVisibilityChanged = $.noop, rtl = false) {
        super(_options, path, onItemsVisibilityChanged, rtl);
        this._options = _options;
        this._resolver = new CodeResolver();
        this._selectedPathSubscription = null;
        this.resolver.done(() => {
            onItemsVisibilityChanged();
        });
        this._selectedPathSubscription = _options.selectedPath.subscribe((newPath) => {
            this._selectItem(!!this.path ? newPath.substr(this.path.length + 1) : newPath);
        });
        this._selectItem(!!this.path ? this.path + '.' + _options.selectedPath() : _options.selectedPath());
    }
    dispose() {
        super.dispose();
        this._resolver.clear();
        if (this._selectedPathSubscription) {
            this._selectedPathSubscription.dispose();
            this._selectedPathSubscription = null;
        }
    }
    walkOnTree(walkCallBack) {
        this._resolver.clear();
        this._visitNextNode(this, walkCallBack);
        if (this['_pageSize'] != -1)
            this._resolver.doneOnce(() => this.items.valueHasMutated());
        return { stop: () => this._resolver.clear() };
    }
    _visitNextNode(item, walkCallback = (_item) => { }) {
        var _a;
        if (item.data && !item.data.specifics)
            throw new Error('Specific should be set');
        if (item.level >= maxSearchLevel())
            return;
        var processItemsFunc = null;
        if (item.items().length > 0) {
            processItemsFunc = () => item.items().forEach(node => {
                walkCallback(node);
                this._visitNextNode(node, walkCallback);
            });
        }
        else if (!item.data || item.treeListController.hasItems(item.data)) {
            if ((_a = item.treeListController.searchOptions) === null || _a === void 0 ? void 0 : _a.autoLoadItems) {
                processItemsFunc = () => item._getItemsWithLock().done(result => {
                    result.forEach((node) => {
                        walkCallback(node);
                        this._visitNextNode(node, walkCallback);
                    });
                });
            }
            else {
                item['_walkCallback'] = (node) => {
                    walkCallback(node);
                    this._visitNextNode(node, walkCallback);
                };
            }
        }
        if (processItemsFunc)
            this._resolver.execute(processItemsFunc, 1);
    }
    _onItemsChanged() {
        if (this._options.expandRootItems)
            this.items().forEach(item => {
                item.collapsed(false);
            });
        super._onItemsChanged();
    }
}

/**
* DevExpress HTML/JS Reporting (designer\dataObjects\expressions\_expressionWrapper.js)
* Version:  22.2.14
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { Disposable, ModelSerializer } from '@devexpress/analytics-core/analytics-utils';
import { editorTemplates } from '@devexpress/analytics-core/analytics-widgets';
import { availableFonts } from '@devexpress/analytics-core/analytics-widgets-internal';
import * as ko from 'knockout';
import { expressionBindingSerializationsInfo } from '../../controls/metadata/properties/expressionBinding';
import { borderDashStyleValues, textAlignmentValues } from '../../controls/metadata/properties/metadata';
import { DataBindingMode } from '../../internal/_dataBindingMode';
import { reportFunctionDisplay } from '../../widgets/customFunctions';
import { designerEditorTemplates } from '../../widgets/editorTemplates';
import { WrappedExpressionOptions } from './_wrappedExpressionOptions';
var colors = ['Transparent', 'AliceBlue', 'AntiqueWhite', 'Aqua', 'Aquamarine', 'Azure', 'Beige', 'Bisque', 'Black', 'BlanchedAlmond', 'Blue', 'BlueViolet', 'Brown', 'BurlyWood', 'CadetBlue', 'Chartreuse', 'Chocolate', 'Coral', 'CornflowerBlue', 'Cornsilk', 'Crimson', 'Cyan', 'DarkBlue', 'DarkCyan', 'DarkGoldenrod', 'DarkGray', 'DarkGreen', 'DarkKhaki', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrange', 'DarkOrchid', 'DarkRed', 'DarkSalmon', 'DarkSeaGreen', 'DarkSlateBlue', 'DarkSlateGray', 'DarkTurquoise', 'DarkViolet', 'DeepPink', 'DeepSkyBlue', 'DimGray', 'DodgerBlue', 'Firebrick', 'FloralWhite', 'ForestGreen', 'Fuchsia', 'Gainsboro', 'GhostWhite', 'Gold', 'Goldenrod', 'Gray', 'Green', 'GreenYellow', 'Honeydew', 'HotPink', 'IndianRed', 'Indigo', 'Ivory', 'Khaki', 'Lavender', 'LavenderBlush', 'LawnGreen', 'LemonChiffon', 'LightBlue', 'LightCoral', 'LightCyan', 'LightGoldenrodYellow', 'LightGreen', 'LightGray', 'LightPink', 'LightSalmon', 'LightSeaGreen', 'LightSkyBlue', 'LightSlateGray', 'LightSteelBlue', 'LightYellow', 'Lime', 'LimeGreen', 'Linen', 'Magenta', 'Maroon', 'MediumAquamarine', 'MediumBlue', 'MediumOrchid', 'MediumPurple', 'MediumSeaGreen', 'MediumSlateBlue', 'MediumSpringGreen', 'MediumTurquoise', 'MediumVioletRed', 'MidnightBlue', 'MintCream', 'MistyRose', 'Moccasin', 'NavajoWhite', 'Navy', 'OldLace', 'Olive', 'OliveDrab', 'Orange', 'OrangeRed', 'Orchid', 'PaleGoldenrod', 'PaleGreen', 'PaleTurquoise', 'PaleVioletRed', 'PapayaWhip', 'PeachPuff', 'Peru', 'Pink', 'Plum', 'PowderBlue', 'Purple', 'Red', 'RosyBrown', 'RoyalBlue', 'SaddleBrown', 'Salmon', 'SandyBrown', 'SeaGreen', 'SeaShell', 'Sienna', 'Silver', 'SkyBlue', 'SlateBlue', 'SlateGray', 'Snow', 'SpringGreen', 'SteelBlue', 'Tan', 'Teal', 'Thistle', 'Tomato', 'Turquoise', 'Violet', 'Wheat', 'White', 'WhiteSmoke', 'Yellow', 'YellowGreen'];
export class ExpressionWrapper extends Disposable {
    constructor(_bindingMode = DataBindingMode.Expressions, _fieldListProvider) {
        super();
        this._bindingMode = _bindingMode;
        this._fieldListProvider = _fieldListProvider;
        this._valuesDictionary = {
            ForeColor: colors,
            BackColor: colors,
            FillColor: colors,
            BorderColor: colors,
            Borders: ['Left', 'Right', 'Top', 'Bottom', 'All'],
            BorderDashStyle: borderDashStyleValues,
            TextAlignment: textAlignmentValues,
            Name: Object.keys(ko.unwrap(availableFonts))
        };
        this._displayNameDictionary = {
            AccessibleDescription: { localizationId: 'DevExpress.XtraReports.UI.XRControl.AccessibleDescription', displayName: 'Accessible Description' },
            Text: { localizationId: 'DevExpress.XtraReports.UI.XRControl.Text', displayName: 'Text' },
            Visible: { localizationId: 'DevExpress.XtraReports.UI.XRControl.Visible', displayName: 'Visible' },
            RowVisible: { localizationId: 'DevExpress.XtraReports.UI.CrossTab.XRCrossTabCell.RowVisible', displayName: 'Row Visible' },
            ColumnVisible: { localizationId: 'DevExpress.XtraReports.UI.CrossTab.XRCrossTabCell.ColumnVisible', displayName: 'Column Visible' },
            NavigateUrl: { localizationId: 'DevExpress.XtraReports.UI.XRControl.NavigateUrl', displayName: 'Navigate Url' },
            Bookmark: { localizationId: 'DevExpress.XtraReports.UI.XRControl.Bookmark', displayName: 'Bookmark' },
            Tag: { localizationId: 'DevExpress.XtraReports.UI.XRControl.Tag', displayName: 'Tag' },
            LeftF: { localizationId: 'DevExpress.XtraReports.UI.XRControl.Left', displayName: 'Left' },
            TopF: { localizationId: 'DevExpress.XtraReports.UI.XRControl.Top', displayName: 'Top' },
            WidthF: { localizationId: 'DevExpress.XtraReports.UI.XRControl.Width', displayName: 'Width' },
            HeightF: { localizationId: 'DevExpress.XtraReports.UI.XRControl.Height', displayName: 'Height' },
            StyleName: { localizationId: 'DevExpress.XtraReports.UI.XRControl.StyleName', displayName: 'Style Name' },
            ForeColor: { localizationId: 'DevExpress.XtraReports.UI.XRControl.ForeColor', displayName: 'Foreground Color' },
            BackColor: { localizationId: 'DevExpress.XtraReports.UI.XRControl.BackColor', displayName: 'Background Color' },
            BorderColor: { localizationId: 'DevExpress.XtraReports.UI.XRControl.BorderColor', displayName: 'Border Color' },
            Borders: { localizationId: 'DevExpress.XtraReports.UI.XRControl.Borders', displayName: 'Borders' },
            BorderWidth: { localizationId: 'DevExpress.XtraReports.UI.XRControl.BorderWidth', displayName: 'Border Width' },
            BorderDashStyle: { localizationId: 'DevExpress.XtraReports.UI.XRControl.BorderDashStyle', displayName: 'Border Dash Style' },
            TextAlignment: { localizationId: 'DevExpress.XtraReports.UI.XRControl.TextAlignment', displayName: 'Text Alignment' },
            Font: { localizationId: 'DevExpress.XtraReports.UI.XRControl.Font', displayName: 'Font' },
            Padding: { localizationId: 'DevExpress.XtraReports.UI.XRControl.Padding', displayName: 'Padding' },
            Appearance: { localizationId: 'ReportStringId.CatAppearance', displayName: 'Appearance' },
            Layout: { localizationId: 'ReportStringId.CatLayout', displayName: 'Layout' },
            Name: { localizationId: 'AnalyticsCoreStringId.FormatFontName', displayName: 'Name' },
            Size: { localizationId: 'AnalyticsCoreStringId.Font.Size', displayName: 'Size' },
            Italic: { localizationId: 'System.Drawing.Font.Italic', displayName: 'Italic' },
            Strikeout: { localizationId: 'System.Drawing.Font.Strikeout', displayName: 'Strikeout' },
            Bold: { localizationId: 'System.Drawing.Font.Bold', displayName: 'Bold' },
            Underline: { localizationId: 'System.Drawing.Font.Underline', displayName: 'Underline' },
            Left: { localizationId: 'AnalyticsCoreStringId.PaddingInfo.Left', displayName: 'Left' },
            Right: { localizationId: 'AnalyticsCoreStringId.PaddingInfo.Right', displayName: 'Right' },
            Top: { localizationId: 'AnalyticsCoreStringId.PaddingInfo.Top', displayName: 'Top' },
            Bottom: { localizationId: 'AnalyticsCoreStringId.PaddingInfo.Bottom', displayName: 'Bottom' },
            CheckBoxState: { localizationId: 'DevExpress.XtraReports.UI.XRCheckBox.CheckBoxState', displayName: 'Check Box State' },
            Image: { localizationId: 'DevExpress.XtraReports.UI.XRPictureBox.Image', displayName: 'Image' },
            ImageSource: { localizationId: 'DevExpress.XtraReports.UI.XRPictureBox.ImageSource', displayName: 'Image Source' },
            ImageUrl: { localizationId: 'DevExpress.XtraReports.UI.XRPictureBox.ImageUrl', displayName: 'Image Url' },
            BinaryData: { localizationId: 'DevExpress.XtraReports.UI.XRBarCode.BinaryData', displayName: 'Binary Data' },
            TargetValue: { localizationId: 'DevExpress.XtraReports.UI.XRGauge.TargetValue', displayName: 'Target Value' },
            ActualValue: { localizationId: 'DevExpress.XtraReports.UI.XRGauge.ActualValue', displayName: 'Actual Value' },
            PrintOnPage: { localizationId: 'DevExpress.XtraReports.UI.XRControlEvents.OnPrintOnPage', displayName: 'PrintOnPage' },
            BeforePrint: { localizationId: 'DevExpress.XtraReports.UI.XRControlEvents.OnBeforePrint', displayName: 'BeforePrint' },
            Minimum: { localizationId: 'DevExpress.XtraReports.UI.XRGauge.Minimum', displayName: 'Minimum' },
            Maximum: { localizationId: 'DevExpress.XtraReports.UI.XRGauge.Maximum', displayName: 'Maximum' },
            FillColor: { localizationId: 'DevExpress.XtraReports.UI.XRShape.FillColor', displayName: 'Fill Color' }
        };
        this._expressionsInfo = {};
        this._expressionsSerializationInfoCache = {};
    }
    dispose() {
        this._expressionsInfo = null;
        this._expressionsSerializationInfoCache = null;
        this._fieldListProvider = null;
    }
    static createExpression(propertyName, eventName, expression) {
        return {
            getInfo: () => expressionBindingSerializationsInfo,
            eventName: ko.observable(eventName),
            expression: ko.observable(expression),
            propertyName: ko.observable(propertyName)
        };
    }
    _createPropertyByName(propertyName, prefix) {
        var result = {
            propertyName: prefix ? [prefix, propertyName].join('.') : propertyName,
            modelName: propertyName,
            displayName: propertyName,
            editor: designerEditorTemplates.getEditor('reportexpressionComplex')
        };
        if (this._displayNameDictionary[propertyName]) {
            result.localizationId = this._displayNameDictionary[propertyName].localizationId;
            result.displayName = this._displayNameDictionary[propertyName].displayName;
        }
        if (this._valuesDictionary[propertyName]) {
            result.valuesArray = this._valuesDictionary[propertyName];
        }
        return result;
    }
    _createInfo(rootInfo, prefix, path) {
        var info = rootInfo;
        for (var i = 0; i < path.length; i++) {
            if (typeof (path[i]) !== 'string' && Array.isArray(path[i])) {
                info.push.apply(info, path[i].map(innerProperty => this._createPropertyByName(innerProperty, path[i - 1])));
            }
            else {
                var currentInfo = info.filter(x => x.propertyName === path[i])[0];
                if (!currentInfo) {
                    currentInfo = this._createPropertyByName(path[i]);
                    if (i !== path.length - 1) {
                        currentInfo.editor = editorTemplates.getEditor('objecteditor');
                        currentInfo.info = [];
                    }
                    info.push(currentInfo);
                }
                info = currentInfo.info;
            }
        }
        return rootInfo;
    }
    _addControlInfo(controlType, ...params) {
        if (!this._expressionsSerializationInfoCache[controlType]) {
            this._expressionsSerializationInfoCache[controlType] = [];
        }
        this._expressionsSerializationInfoCache[controlType] = this._createInfo(this._expressionsSerializationInfoCache[controlType], '', params.filter(x => !!x));
    }
    _createSerializationInfo(controlType, useEvents = false) {
        var propertyNames = Object.keys(this._expressionsInfo[controlType]);
        propertyNames.forEach((propertyName) => {
            var propertyDescriptor = this._expressionsInfo[controlType][propertyName];
            if (!useEvents) {
                if (propertyDescriptor.events.indexOf('BeforePrint') !== -1)
                    this._addControlInfo(controlType, propertyDescriptor.group, propertyName, propertyDescriptor.objectProperties);
            }
            else {
                propertyDescriptor.events.forEach((eventName) => {
                    this._addControlInfo(controlType, eventName, propertyDescriptor.group, propertyName, propertyDescriptor.objectProperties);
                });
            }
        });
    }
    _getPropertyDescriptors(controlType, expressionName) {
        var propertyNames = Object.keys(this._expressionsInfo[controlType]);
        if (!propertyNames.some(propertyName => propertyName === expressionName))
            return null;
        return this._expressionsInfo[controlType][expressionName];
    }
    _getExpressionFromArray(propertyName, eventName, expressions) {
        return expressions().filter(x => x.propertyName() === propertyName &&
            x.eventName() === eventName)[0];
    }
    _createExpressionMap(propertyName, eventName, expressions, subscriptions, path, summaryRunning) {
        var functions = !!summaryRunning && !!summaryRunning(propertyName)
            ? ko.computed(() => summaryRunning(propertyName)() ? this._summaryFunctions() : reportFunctionDisplay)
            : reportFunctionDisplay;
        var expressionOptions = new WrappedExpressionOptions({
            path: path || ko.observable(''),
            functions: functions
        }, {
            addExpression: (newVal) => {
                expressions.push(ExpressionWrapper.createExpression(propertyName, eventName, newVal));
            },
            removeExpression: (expression) => {
                expressions.remove(expression);
            }
        }, this._fieldListProvider, eventName);
        expressionOptions._disposables.push(functions);
        expressionOptions.expression(this._getExpressionFromArray(propertyName, eventName, expressions));
        return expressionOptions;
    }
    _summaryFunctions() {
        var createNewItemDelegate = (funcName, paramCount) => {
            return [{
                    paramCount: paramCount,
                    text: 'sum' + funcName + '()',
                    descriptionStringId: 'ReportStringId.ExpressionEditor_Description_Function_Summary' + funcName
                }];
        };
        var summaryCategory = {
            display: 'Summary',
            localizationId: 'ReportStringId.ExpressionEditor_ItemInfo_FunctionSummary',
            category: 'Summary',
            items: {}
        };
        ['Avg', 'Count', 'Sum', 'RunningSum', 'Percentage', 'Max', 'Min', 'Median', 'Var', 'VarP', 'StdDev', 'StdDevP', 'DAvg', 'DCount', 'DSum', 'DVar', 'DVarP', 'DStdDev', 'DStdDevP', 'RecordNumber',
            { name: 'WAvg', paramCount: 2 }
        ].forEach(func => {
            if (typeof func === 'string') {
                summaryCategory.items[func] = createNewItemDelegate(func, 1);
            }
            else {
                summaryCategory.items[func.name] = createNewItemDelegate(func.name, func.paramCount);
            }
        });
        return reportFunctionDisplay
            .filter(cat => cat.category != 'Aggregate')
            .concat([summaryCategory]);
    }
    _mapExpressionsToObjectByEventName(object, eventName, expressions, subscriptions, path, summaryRunning) {
        var properties = object.getInfo();
        properties.forEach(info => {
            if (!ko.isObservable(object[info.propertyName])) {
                this._mapExpressionsToObjectByEventName(object[info.propertyName], eventName, expressions, subscriptions, path, summaryRunning);
            }
            else {
                object[info.propertyName] = this._createExpressionMap(info.propertyName, eventName, expressions, subscriptions, path, summaryRunning);
                object[info.propertyName].serializationInfo = info;
                subscriptions.push(object[info.propertyName]);
            }
        });
    }
    _allExpressions(object, condition) {
        var positive = true;
        var properties = object.getInfo();
        properties.forEach(info => {
            if (!positive)
                return;
            if (object[info.propertyName] instanceof Object && !(object[info.propertyName] instanceof WrappedExpressionOptions)) {
                positive = this._allExpressions(object[info.propertyName], condition);
            }
            else {
                positive = condition(object[info.propertyName]);
            }
        });
        return positive;
    }
    _isValidExpressions(object) {
        return this._allExpressions(object, (expr) => expr.isValid());
    }
    _isWarningExpressions(object) {
        return !this._allExpressions(object, (expr) => !expr.warningMessage());
    }
    _getExpressionByPropertyName(object, propertyNameToSearch) {
        if (!object)
            return;
        if (object[propertyNameToSearch]) {
            return object[propertyNameToSearch];
        }
        else {
            var properties = object.getInfo();
            var innerObjectPropertyNames = properties.filter(info => !(object[info.propertyName] instanceof WrappedExpressionOptions));
            for (var i = 0; i < innerObjectPropertyNames.length; i++) {
                var result = this._getExpressionByPropertyName(object[innerObjectPropertyNames[i].propertyName], propertyNameToSearch);
                if (result)
                    return result;
            }
        }
    }
    _mapExpressionsToObject(controlType, expressions, path, summaryRunning) {
        if (this._bindingMode === DataBindingMode.Bindings) {
            return null;
        }
        var useEvents = this._bindingMode === DataBindingMode.ExpressionsAdvanced;
        var subscriptions = [];
        if (!this._expressionsSerializationInfoCache[controlType]) {
            this._createSerializationInfo(controlType, useEvents);
        }
        var stateObj = {
            getInfo: () => { return this._expressionsSerializationInfoCache[controlType]; },
            getExpression: (propertyName, eventName) => {
                if (useEvents) {
                    return this._getExpressionByPropertyName(stateObj[eventName], propertyName);
                }
                else {
                    return this._getExpressionByPropertyName(stateObj, propertyName);
                }
            },
            getExpressionsTreeItems: (expressionName) => {
                var propertyDescriptor = this._getPropertyDescriptors(controlType, expressionName);
                if (!propertyDescriptor)
                    return null;
                var expressionTreeItems = [];
                var isComplexProperty = !!(propertyDescriptor.objectProperties || []).length;
                var generateExpressionItem = (currentExpressionName, parentExpressionName) => {
                    var expressionTreeItem = {
                        innerItems: null,
                        expressionName: currentExpressionName,
                    };
                    var expressionObjPropertyName = parentExpressionName ? [parentExpressionName, currentExpressionName].join('.') : currentExpressionName;
                    if (useEvents) {
                        propertyDescriptor.events.forEach((eventName) => {
                            var innerExpressionObj = stateObj.getExpression(expressionObjPropertyName, eventName);
                            if (!innerExpressionObj)
                                return;
                            var serializationInfo = innerExpressionObj['serializationInfo'];
                            expressionTreeItem.displayName = serializationInfo && serializationInfo.displayName;
                            expressionTreeItem.localizationId = serializationInfo && serializationInfo.localizationId;
                            expressionTreeItem.innerItems = expressionTreeItem.innerItems || [];
                            var eventInfo = this._displayNameDictionary[eventName];
                            expressionTreeItem.innerItems.push({
                                eventName: eventName,
                                displayName: eventInfo && eventInfo.displayName,
                                localizationId: eventInfo && eventInfo.localizationId,
                                expressionName: currentExpressionName,
                                expressionObj: innerExpressionObj
                            });
                        });
                    }
                    else {
                        var innerExpressionObj = stateObj.getExpression(expressionObjPropertyName);
                        if (!innerExpressionObj)
                            return;
                        expressionTreeItem.expressionObj = innerExpressionObj;
                        var serializationInfo = innerExpressionObj['serializationInfo'];
                        expressionTreeItem.displayName = serializationInfo.displayName;
                        expressionTreeItem.localizationId = serializationInfo.localizationId;
                    }
                    expressionTreeItems.push(expressionTreeItem);
                };
                if (isComplexProperty) {
                    (propertyDescriptor.objectProperties || []).forEach((innerExpresionName) => { generateExpressionItem(innerExpresionName, expressionName); });
                }
                else {
                    generateExpressionItem(expressionName);
                }
                return expressionTreeItems;
            },
            dispose: () => {
                subscriptions.forEach(x => x.dispose());
                subscriptions.splice(0);
            },
            validateExpression: () => {
                return this._isValidExpressions(stateObj);
            },
            hasWarning: () => {
                return this._isWarningExpressions(stateObj);
            }
        };
        new ModelSerializer().deserialize(stateObj, {});
        if (useEvents) {
            var properties = stateObj.getInfo();
            properties.forEach(info => {
                this._mapExpressionsToObjectByEventName(stateObj[info.propertyName], info.propertyName, expressions, subscriptions, path, summaryRunning);
            });
        }
        else {
            this._mapExpressionsToObjectByEventName(stateObj, 'BeforePrint', expressions, subscriptions, path, summaryRunning);
        }
        subscriptions.push(expressions.subscribe((args) => {
            args.forEach(arg => {
                if (arg.status === 'deleted') {
                    stateObj.getExpression(arg.value.propertyName(), arg.value.eventName()).expression(null);
                }
                else if (arg.status === 'added') {
                    stateObj.getExpression(arg.value.propertyName(), arg.value.eventName()).expression(arg.value);
                }
            });
        }, null, 'arrayChange'));
        return { stateObj, subscriptions };
    }
    setPropertyDescription(controlType, propertyName, events, objectProperties, group) {
        if (!this._expressionsInfo[controlType])
            this._expressionsInfo[controlType] = {};
        this._expressionsInfo[controlType][propertyName] = {
            events: events,
            group: group,
            objectProperties: objectProperties
        };
    }
    hidePropertyDescriptions(controlType, ...propertyNames) {
        propertyNames.forEach(propertyName => {
            if (propertyName.indexOf('.') !== -1) {
                var propertyPath = propertyName.split('.');
                if (propertyPath.length > 2)
                    return;
                var expressionInfo = this._expressionsInfo[controlType][propertyPath[0]];
                if (!expressionInfo || !expressionInfo.objectProperties)
                    return;
                var index = expressionInfo.objectProperties.indexOf(propertyPath[1]);
                if (index === -1)
                    return;
                expressionInfo.objectProperties.splice(index, 1);
                if (expressionInfo.objectProperties.length === 0)
                    delete this._expressionsInfo[controlType][propertyPath[0]];
                return;
            }
            delete this._expressionsInfo[controlType][propertyName];
        });
    }
    createExpressionsObject(controlType, expressions, path, summaryRunning) {
        var result = this._mapExpressionsToObject(controlType, expressions, path, summaryRunning);
        if (!result)
            return;
        return result.stateObj;
    }
    setLocalizationId(propertyName, localizationId, displayName) {
        this._displayNameDictionary[propertyName] = {
            localizationId: localizationId,
            displayName: displayName || propertyName
        };
    }
    setValues(propertyName, values) {
        this._valuesDictionary[propertyName] = values;
    }
}

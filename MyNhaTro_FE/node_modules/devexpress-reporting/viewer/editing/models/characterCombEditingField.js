/**
* DevExpress HTML/JS Reporting (viewer\editing\models\characterCombEditingField.js)
* Version:  22.2.14
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { focusTextElement, TextEditingFieldViewModelBase } from './textEditingField';
import { brickStyleSerializationsInfo } from '../../../common/metadata';
import { ModelSerializer } from '@devexpress/analytics-core/analytics-utils';
import { CssCalculator } from '@devexpress/analytics-core/analytics-internal';
import * as ko from 'knockout';
import * as $ from 'jquery';
export class CharacterCombEditingFieldViewModel extends TextEditingFieldViewModelBase {
    constructor(field, pageWidth, pageHeight, zoom, bounds) {
        super();
        this.field = field;
        this.template = 'dxrp-character-comb-editing-field';
        this.active = ko.observable(false);
        var brickStyle = field.model().brickOptions;
        var style = { rtl: () => brickStyle.rtl };
        new ModelSerializer().deserialize(style, JSON.parse(brickStyle.style), brickStyleSerializationsInfo);
        var cssCalculator = new CssCalculator(style, ko.observable(!!brickStyle.rtlLayout));
        var verticalPadding = parseInt(cssCalculator.paddingsCss()['paddingTop']) + parseInt(cssCalculator.paddingsCss()['paddingBottom']);
        var borderCss = cssCalculator.borderCss();
        if (borderCss['borderTop'] !== 'none') {
            verticalPadding += style['borderWidth']();
        }
        if (borderCss['borderBottom'] !== 'none') {
            verticalPadding += style['borderWidth']();
        }
        this.textStyle = () => $.extend({}, cssCalculator.fontCss(), cssCalculator.foreColorCss(), cssCalculator.textAlignmentCss());
        this.hideEditor = (shouldCommit) => {
            setTimeout(() => {
                if (shouldCommit) {
                    field.editValue(field._editorValue());
                }
                else {
                    field._editorValue(field.editValue());
                }
                this.active(false);
            });
        };
        this.containerStyle = ko.pureComputed(() => {
            return $.extend({
                width: bounds.width + 'px',
                height: bounds.height + 'px',
                'line-height': (bounds.height - verticalPadding) + 'px',
                top: bounds.top * 100 / pageHeight + '%',
                left: bounds.left * 100 / pageWidth + '%'
            }, cssCalculator.fontCss(), cssCalculator.foreColorCss());
        });
        var cellVerticalPadding = 0;
        var borderCellStyle = 'none';
        ['Left', 'Top', 'Right', 'Bottom'].forEach((item) => {
            if (borderCss['border' + item] !== 'none') {
                borderCellStyle = borderCss['border' + item];
                cellVerticalPadding = style['borderWidth']() * 2;
            }
        });
        var cellStyle = {
            'border': borderCellStyle,
            'text-align': 'center',
            'position': 'absolute',
            'box-sizing': 'border-box',
            'border-color': 'transparent'
        };
        var characterCombBounds = field.model().brickOptions.characterCombBounds;
        this.cells = [];
        var rowTops = {};
        for (var i = 0; i < characterCombBounds.length; i++) {
            this.cells.push({
                style: $.extend({
                    width: characterCombBounds[i].width + 'px',
                    height: characterCombBounds[i].height + 'px',
                    'line-height': (characterCombBounds[i].height - cellVerticalPadding) + 'px',
                    top: characterCombBounds[i].top + 'px',
                    left: characterCombBounds[i].left + 'px'
                }, cellStyle),
                text: ''
            });
            rowTops[characterCombBounds[i].top] = i;
        }
        var rowsCount = Object.keys(rowTops).length;
        var colsCount = this.cells.length / rowsCount;
        CharacterCombEditingFieldViewModel.setText(this.cells, style['textAlignment'](), style.rtl(), field.editValue.peek(), rowsCount, colsCount);
        field.editValue.subscribe(newValue => {
            CharacterCombEditingFieldViewModel.setText(this.cells, style['textAlignment'](), style.rtl(), newValue, rowsCount, colsCount);
        });
        this.zoom = zoom;
    }
    activateEditor(viewModel, e) {
        if (!this.field.readOnly() && !this.active()) {
            this.active(true);
            focusTextElement(e && e.currentTarget);
        }
    }
    static setText(cells, textAlignment, rtl, text, rowsCount, colsCount) {
        for (var j = 0; j < cells.length; j++) {
            cells[j].text = '';
        }
        var textRowsCount = Math.ceil(text.length / colsCount);
        var textLastRowColCount = text.length % colsCount;
        var startRow = -1;
        if (textAlignment.indexOf('Bottom') === 0) {
            startRow = rowsCount - textRowsCount;
        }
        else if (textAlignment.indexOf('Middle') === 0) {
            startRow = Math.floor((rowsCount - textRowsCount) / 2);
        }
        else {
            startRow = 0;
        }
        var lastRowStartCol = -1;
        if (textAlignment.indexOf('Right') > 0) {
            lastRowStartCol = rtl ? 0 : (colsCount - textLastRowColCount);
        }
        else if (textAlignment.indexOf('Center') > 0) {
            lastRowStartCol = Math.floor((colsCount - textLastRowColCount) / 2);
        }
        else {
            lastRowStartCol = rtl ? (colsCount - textLastRowColCount) : 0;
        }
        var j = startRow * colsCount;
        var i = 0;
        for (; i < text.length - textLastRowColCount; i++, j++) {
            if (j >= 0 && j < cells.length) {
                cells[j].text = text[i];
            }
        }
        for (; i < text.length; i++, j++) {
            if (j >= 0 && j < cells.length) {
                cells[j + lastRowStartCol].text = text[i];
            }
        }
    }
}

/**
* DevExpress HTML/JS Reporting (viewer\editing\models\textEditingField.js)
* Version:  22.2.14
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { brickStyleSerializationsInfo } from '../../../common/metadata';
import { EditingFieldExtensions } from '../../../common/utils/editingFieldExtensions';
import { ModelSerializer } from '@devexpress/analytics-core/analytics-utils';
import { processTextEditorHotKeys, CssCalculator } from '@devexpress/analytics-core/analytics-internal';
import * as ko from 'knockout';
import * as $ from 'jquery';
export class TextEditingFieldViewModelBase {
    keypressAction(data, event) {
        processTextEditorHotKeys(event, {
            esc: () => {
                this.hideEditor(false);
            },
            ctrlEnter: () => {
                this.hideEditor(true);
            }
        });
    }
}
export class TextEditingFieldViewModel extends TextEditingFieldViewModelBase {
    constructor(field, pageWidth, pageHeight, zoom, bounds) {
        super();
        this.template = 'dxrp-editing-field-container';
        this.htmlValue = () => this.field.htmlValue();
        this.wordWrap = true;
        this.active = ko.observable(false);
        var brickStyle = field.model().brickOptions;
        var style = { rtl: () => brickStyle.rtl };
        new ModelSerializer().deserialize(style, JSON.parse(brickStyle.style), brickStyleSerializationsInfo);
        var cssCalculator = new CssCalculator(style, ko.observable(!!brickStyle.rtlLayout));
        var padding = cssCalculator.paddingsCss();
        var verticalPadding = parseInt(padding['paddingTop']) + parseInt(padding['paddingBottom']);
        if (cssCalculator.borderCss()['borderTop'] !== 'none') {
            verticalPadding += style['borderWidth']();
        }
        if (cssCalculator.borderCss()['borderBottom'] !== 'none') {
            verticalPadding += style['borderWidth']();
        }
        this.breakOffsetStyle = () => {
            return {
                top: bounds.offset.y * -100 / bounds.height + '%',
                left: bounds.offset.x * -100 / bounds.width + '%'
            };
        };
        this.textStyle = () => $.extend({}, cssCalculator.fontCss(), cssCalculator.foreColorCss(), cssCalculator.textAlignmentCss());
        this.zoom = zoom;
        this.field = field;
        if (brickStyle.wordWrap != undefined) {
            this.wordWrap = brickStyle.wordWrap;
        }
        this.hideEditor = (shouldCommit) => {
            setTimeout(() => {
                if (shouldCommit && this.active()) {
                    if (editorOptions.onHideEditor) {
                        editorOptions.onHideEditor(field);
                    }
                    else {
                        field.editValue(field._editorValue());
                    }
                }
                else {
                    field._editorValue(field.editValue());
                }
                this.active(false);
            }, 1);
        };
        var editor = EditingFieldExtensions.instance().editor(field.editorName());
        var editorOptions = $.extend(true, {}, editor && editor.options || {});
        this.data = {
            value: field._editorValue,
            hideEditor: this.hideEditor,
            keypressAction: this.keypressAction,
            textStyle: this.textStyle,
            options: editorOptions,
            getOptions: (templateOptions) => { return $.extend({}, this.data.options, templateOptions); }
        };
        var isCustomEditor = !!(editor && editor.template && editor.template !== 'dxrp-editing-field-datetime');
        if (!isCustomEditor) {
            var self = this;
            this.data.options = $.extend(true, {}, editorOptions, {
                value: field._editorValue,
                onFocusOut: (e) => {
                    self.hideEditor(true);
                }
            });
        }
        if (editor) {
            this.editorTemplate = editor.template || 'dxrp-editing-field-mask';
        }
        else {
            this.editorTemplate = 'dxrp-editing-field-text';
        }
        this.containerStyle = ko.pureComputed(() => {
            return $.extend({
                width: bounds.width + 'px',
                height: bounds.height + 'px',
                'line-height': (bounds.height - verticalPadding) + 'px',
                top: bounds.top * 100 / pageHeight + '%',
                left: bounds.left * 100 / pageWidth + '%',
                cursor: this.field.readOnly() ? 'auto' : 'text'
            }, this.active() || !this.htmlValue() ? cssCalculator.borderCss() : { border: 'none' }, isCustomEditor && this.active() || (!!this.htmlValue() && !this.active()) ? { padding: 0 } : cssCalculator.paddingsCss(), { 'border-color': 'transparent' });
        });
        this.borderStyle = ko.pureComputed(() => {
            if (style['borderWidth']() > 0 && style['borders']() !== 'None') {
                return {
                    left: '-' + style['borderWidth']() + 'px',
                    top: '-' + style['borderWidth']() + 'px',
                    paddingRight: (style['borderWidth']() * 2 - 2) + 'px',
                    paddingBottom: (style['borderWidth']() * 2 - 2) + 'px'
                };
            }
        });
    }
    activateEditor(viewModel, e) {
        if (this.field.readOnly() || this.active()) {
            return;
        }
        var data = viewModel.data;
        if (data && data.options && data.options.onPreRender) {
            data.options.onPreRender(this.data);
        }
        this.active(true);
        var elementFocused = false;
        if (viewModel.options && viewModel.options.onEditorShown) {
            elementFocused = viewModel.options.onEditorShown(this.data, $.fn.constructor(e && e.currentTarget).first().get(0));
        }
        if (!elementFocused) {
            focusTextElement(e && e.currentTarget);
        }
    }
}
export function focusTextElement(target) {
    var element = $.fn.constructor(target).find('input').eq(0)[0];
    if (!element)
        element = $.fn.constructor(target).find('textarea').eq(0)[0];
    element.focus();
    if (element['setSelectionRange']) {
        element['setSelectionRange'](element['value'].length, element['value'].length);
    }
}

/**
* DevExpress HTML/JS Reporting (viewer\widgets\pictureEditor\_imagePainter.js)
* Version:  22.2.14
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as $ from 'jquery';
import * as ko from 'knockout';
import { ImageAlignment, ImageSizeMode } from '../../editing/editingField';
export class ImagePainter {
    constructor(options) {
        this.format = ko.observable();
        this.image = options.imageSource;
        this.sizeMode = options.sizeMode;
        this.alignment = options.alignment;
    }
    _drawImage(imageSource, context, scale, contentSize) {
        var deferred = $.Deferred();
        if (!imageSource)
            return deferred.resolve().promise();
        var background = new Image();
        var prefix = 'data:image/' + (this.format() || 'png') + ';base64,';
        if (this.format() === 'svg') {
            prefix = 'data:image/svg+xml;charset=UTF-8;base64,';
        }
        var imageBase64 = imageSource.indexOf('base64,') !== -1 ? imageSource : prefix + imageSource;
        background.src = imageBase64;
        background.onload = () => {
            var size = this._getImageSize(background, scale, contentSize);
            var location = this._getImageCoordinate(size, contentSize);
            context.drawImage(background, location.x, location.y, size.width, size.height);
            deferred.resolve();
        };
        return deferred.promise();
    }
    _getImageSize(image, scale, contentSize) {
        var sizeMode = this.sizeMode();
        var width = image.width * scale, height = image.height * scale;
        if (sizeMode === ImageSizeMode.StretchImage) {
            width = contentSize.width;
            height = contentSize.height;
        }
        else if (sizeMode === ImageSizeMode.Cover || sizeMode === ImageSizeMode.ZoomImage || (sizeMode === ImageSizeMode.Squeeze && (contentSize.width < width || contentSize.height < height))) {
            var ratio = (sizeMode === ImageSizeMode.Cover ? Math.max : Math.min)(contentSize.width / width, contentSize.height / height);
            width *= ratio;
            height *= ratio;
        }
        return { width: width, height: height };
    }
    _getImageCoordinate(imageSize, contentSize) {
        var alignment = this.alignment();
        var x = 0, y = 0;
        if (!(alignment in ImageAlignment) && (this.sizeMode() === ImageSizeMode.Cover || this.sizeMode() === ImageSizeMode.ZoomImage || this.sizeMode() === ImageSizeMode.Squeeze)) {
            alignment = ImageAlignment.MiddleCenter;
        }
        if (alignment === ImageAlignment.MiddleLeft || alignment === ImageAlignment.MiddleCenter || alignment === ImageAlignment.MiddleRight) {
            y = (contentSize.height - imageSize.height) / 2;
        }
        else if (alignment === ImageAlignment.BottomLeft || alignment === ImageAlignment.BottomCenter || alignment === ImageAlignment.BottomRight) {
            y = contentSize.height - imageSize.height;
        }
        if (alignment === ImageAlignment.TopCenter || alignment === ImageAlignment.MiddleCenter || alignment === ImageAlignment.BottomCenter) {
            x = (contentSize.width - imageSize.width) / 2;
        }
        else if (alignment === ImageAlignment.TopRight || alignment === ImageAlignment.MiddleRight || alignment === ImageAlignment.BottomRight) {
            x = contentSize.width - imageSize.width;
        }
        return { x: x, y: y };
    }
    refresh(context, scale = 1, contentSize) {
        contentSize = contentSize || {
            width: context.canvas.width,
            height: context.canvas.height
        };
        return this._drawImage(this.image(), context, scale, contentSize);
    }
}

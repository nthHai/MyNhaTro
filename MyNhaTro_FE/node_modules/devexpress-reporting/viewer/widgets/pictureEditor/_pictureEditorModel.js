/**
* DevExpress HTML/JS Reporting (viewer\widgets\pictureEditor\_pictureEditorModel.js)
* Version:  22.2.14
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { addDisposeCallback, getParentContainer, uploadFile } from '@devexpress/analytics-core/analytics-internal';
import { Disposable } from '@devexpress/analytics-core/analytics-utils';
import { getTemplate } from '@devexpress/analytics-core/analytics-widgets';
import * as events from 'devextreme/events';
import dxPopup from 'devextreme/ui/popup';
import * as $ from 'jquery';
import * as ko from 'knockout';
import { ImageEditingFieldViewModel } from '../../editing/models/imageEditingField';
import { PictureEditMode } from './pictureEditMode';
import { Painter } from './_painter';
import { PictureEditorActionProvider } from './_pictureEditorActionProvider';
export class PictureEditorModel extends Disposable {
    constructor(options, element) {
        super();
        this.GESTURE_COVER_CLASS = 'dx-gesture-cover';
        this.ACTIVE_POPUP_CLASS = '.dx-picture-editing-active';
        this._getPopupContent = () => {
            var popupInstance = dxPopup['getInstance'](this.$element.find(this.ACTIVE_POPUP_CLASS).get(0));
            return popupInstance && $.fn.constructor(popupInstance.content());
        };
        this.getPopupContainer = getParentContainer;
        this.actions = [];
        this.canDraw = ko.observable(false);
        this._initialImageType = ko.unwrap(options.imageType) || 'png';
        this.zoom = options.zoom || ko.observable(1);
        this.editMode = ko.unwrap(options.imageMode) || PictureEditMode.Image;
        this._initialImage = ko.unwrap(options.image);
        this._initialAlignment = ko.unwrap(options.alignment);
        this._initialSizeMode = ko.unwrap(options.sizeMode);
        this._callbacks = options.callbacks;
        this.$element = $.fn.constructor(element);
        this.shadingEnabled = options.shadingEnabled;
        this.active = ko.isObservable(options.active) ? options.active : ko.observable(!!options.active);
        var painterOptions = {
            alignment: this._initialAlignment,
            canDraw: this.editMode !== PictureEditMode.Image && this.canDraw,
            imageSource: this._initialImage,
            imageType: this._initialImageType,
            sizeMode: this._initialSizeMode,
            zoom: this.zoom
        };
        this.painter = new Painter(painterOptions);
        this._disposables.push(this.painter);
        this.painter.initSize(this.$element, this.zoom());
        this.actionsProvider = new PictureEditorActionProvider(this, $.extend(true, {
            getPositionTarget: () => {
                return this._getPopupContent().find('.dx-picture-editing-toolbar');
            }
        }, (options.popupOptions || {})));
        this._disposables.push(this.actionsProvider);
        this._initActions(options.callbacks && options.callbacks.customizeActions);
        this.applyBindings();
    }
    _takeFocus() {
        if (!this.active()) {
            this._callbacks && this._callbacks.onFocusIn && this._callbacks.onFocusIn(this);
            this.active(true);
        }
        else if (this.editMode !== PictureEditMode.Image) {
            this.canDraw(true);
            this._callbacks && this._callbacks.onDraw && this._callbacks.onDraw(this);
        }
    }
    _releaseFocus() {
        if (this.active()) {
            this._callbacks && this._callbacks.onFocusOut && this._callbacks.onFocusOut(this);
            this.active(false);
            this.canDraw(false);
        }
    }
    _wrapButtonAction(item, model) {
        var oldAction = item.action;
        item.action = (sender, event) => {
            model.changeActiveButton(sender);
            if (oldAction)
                oldAction(event, model);
        };
    }
    _initActions(customizeActionsCallback) {
        if (this.editMode == PictureEditMode.Image || this.editMode == PictureEditMode.ImageAndSignature) {
            this.actions.push(this.actionsProvider.createOpenFileAction((e) => this._loadImage(e)));
            this.actions.push(this.actionsProvider.createSizingAction());
        }
        if (this.editMode == PictureEditMode.Signature || this.editMode == PictureEditMode.ImageAndSignature) {
            this.actions.push(this.actionsProvider.createBrushAction());
        }
        if (!!this._initialImage) {
            this.actions.push(this.actionsProvider.createResetItem(() => {
                this.painter.reset(this._initialImage, this._initialAlignment, this._initialSizeMode, this._initialImageType);
            }));
        }
        this.actions.push(this.actionsProvider.createClearItem(() => {
            this.painter.clear();
        }));
        customizeActionsCallback && customizeActionsCallback(this, this.actions);
        this.actions.forEach((item) => this._wrapButtonAction(item, this));
    }
    _loadImage(event) {
        event.stopPropagation();
        event.preventDefault();
        uploadFile({
            accept: 'image/*'
        }).done(result => {
            this.painter.format(result.format);
            this.painter.image(result.content);
            this.painter.refresh();
        });
    }
    _addEvents() {
        this._pointerDownHandler = (e) => {
            this._takeFocus();
        };
        this._pointerCancelHandler = (e) => {
            this._releaseFocus();
        };
        this._pointerUpHandler = (e) => {
            if (!this.active())
                return;
            var isUnderCursor = (componentContent) => {
                return componentContent && (componentContent.is(e.target) || componentContent.has(e.target).length > 0);
            };
            var isEditorContainer = this.$element.is(e.target) || this.$element.has(e.target).length > 0
                || isUnderCursor(this._getPopupContent())
                || this.actions.some(a => {
                    if (!a.active())
                        return false;
                    var component = ko.unwrap(a.component);
                    return isUnderCursor(component && $.fn.constructor(component.content()));
                })
                || (e.target && e.target.className && e.target.className.indexOf && e.target.className.indexOf(this.GESTURE_COVER_CLASS) !== -1);
            if (!isEditorContainer) {
                this._releaseFocus();
            }
        };
        var element = this.$element.get(0);
        events.on(element, 'dxpointerdown', this._pointerDownHandler);
        events.on(element, 'dxpointercancel', this._pointerCancelHandler);
        events.on(document, 'dxpointerup', this._pointerUpHandler);
    }
    changeActiveButton(selectedItem) {
        this.actions.forEach(action => {
            action.active(action === selectedItem && !action.active());
        });
    }
    applyBindings() {
        ko.cleanNode(this.$element[0]);
        ko.applyBindings(this, this.$element[0]);
        this._addEvents();
        this.painter.initCanvas(this.$element, this.zoom());
    }
    dispose() {
        super.dispose();
        var element = this.$element.get(0);
        events.off(element, 'dxpointerdown', this._pointerDownHandler);
        events.off(element, 'dxpointercancel', this._pointerCancelHandler);
        events.off(document, 'dxpointerup', this._pointerUpHandler);
        this.actions.forEach(action => action.dispose && action.dispose());
        this.$element = null;
    }
    getImage() {
        return this.painter.getImage();
    }
    reset(image, alignment, sizeMode, imageType) {
        this._initialImage = image;
        this._initialAlignment = alignment;
        this._initialSizeMode = sizeMode;
        this._initialImageType = imageType;
        this.painter.reset(this._initialImage, this._initialAlignment, this._initialSizeMode, this._initialImageType);
    }
    getCurrentOptions() {
        var imageBase64 = (this.painter.hasSignature() ? this.painter.getImage() : this.painter.image()) || '';
        var imageParts = imageBase64.split(',');
        return {
            sizeMode: this.painter.imageSizeMode(),
            alignment: this.painter.imageAlignment(),
            imageType: this.painter.hasSignature() ? ImageEditingFieldViewModel.__DefaultImageType : this.painter.format(),
            image: imageParts[imageParts.length - 1]
        };
    }
}
ko.bindingHandlers['dxPictureEditor'] = {
    init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        var options = (valueAccessor());
        $.fn.constructor(element).children().remove();
        var templateHtml = getTemplate('dx-picture-editing');
        var $element = $.fn.constructor(element).append(templateHtml);
        var child = $element.children()[0];
        var model = new PictureEditorModel(options, child);
        addDisposeCallback(element, function () {
            model.dispose();
        });
        return { controlsDescendantBindings: true };
    }
};

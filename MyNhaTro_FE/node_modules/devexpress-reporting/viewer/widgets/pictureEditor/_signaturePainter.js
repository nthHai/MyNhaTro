/**
* DevExpress HTML/JS Reporting (viewer\widgets\pictureEditor\_signaturePainter.js)
* Version:  22.2.14
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { Disposable } from '@devexpress/analytics-core/analytics-utils';
import * as ko from 'knockout';
export class SignaturePainter extends Disposable {
    constructor() {
        super();
        this._points = ko.observableArray([]);
        this.hasPoints = ko.computed(() => { return this._points().length > 0; });
        this._disposables.push(this.hasPoints);
    }
    dispose() {
        super.dispose();
        this.reset();
    }
    _drawPath(context, x, y, lastX, lastY, color, lineWidth) {
        context.beginPath();
        context.strokeStyle = color;
        context.lineWidth = lineWidth;
        context.lineJoin = 'round';
        context.moveTo(lastX, lastY);
        context.lineTo(x, y);
        context.closePath();
        context.stroke();
    }
    _drawCircle(context, x, y, color, lineWidth) {
        context.beginPath();
        context.fillStyle = color;
        context.arc(x, y, lineWidth / 2, 0, 2 * Math.PI, false);
        context.fill();
    }
    _drawAllPoints(context) {
        this._points().forEach((point) => {
            if (point.isStart) {
                this._drawCircle(context, point.x, point.y, point.color, point.width);
            }
            else {
                this._drawPath(context, point.x, point.y, point.lastX, point.lastY, point.color, point.width);
            }
        });
    }
    drawCircle(context, x, y, color, width) {
        this._lastX = x;
        this._lastY = y;
        this._drawCircle(context, x, y, color, width);
        this._points.push({ x: this._lastX, y: this._lastY, color: color, width: width, isStart: true });
    }
    drawPath(context, x, y, color, width) {
        this._drawPath(context, x, y, this._lastX, this._lastY, color, width);
        this._points.push({ x: x, y: y, lastX: this._lastX, lastY: this._lastY, color: color, width: width });
        this._lastX = x;
        this._lastY = y;
    }
    resetLastPosition() {
        this._lastX = undefined;
        this._lastY = undefined;
    }
    resetPoints() {
        this._points([]);
    }
    reset() {
        this.resetLastPosition();
        this.resetPoints();
    }
    refresh(context) {
        this._drawAllPoints(context);
    }
}

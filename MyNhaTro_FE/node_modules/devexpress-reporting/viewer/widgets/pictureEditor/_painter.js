/**
* DevExpress HTML/JS Reporting (viewer\widgets\pictureEditor\_painter.js)
* Version:  22.2.14
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { ImageSizeMode, ImageAlignment } from '../../editing/editingField';
import { ImagePainter } from './_imagePainter';
import { SignaturePainter } from './_signaturePainter';
import { ImageEditingFieldViewModel } from '../../editing/models/imageEditingField';
import { Disposable } from '@devexpress/analytics-core/analytics-utils';
import { addDisposeCallback } from '@devexpress/analytics-core/analytics-internal';
import * as ko from 'knockout';
import * as $ from 'jquery';
import * as events from 'devextreme/events';
import { getTemplate } from '@devexpress/analytics-core/analytics-widgets';
export class Painter extends Disposable {
    constructor(options) {
        super();
        this._pointerDownHandler = (e) => {
            var point = this._getContextPoint(e);
            point && this.signaturePainter.drawCircle(this._context, point.x, point.y, this.lineColor(), this.lineWidth());
        };
        this._pointerMoveHandler = (e) => {
            if (e.pointerType === 'touch' || e.pointerType === 'pen' || (e.pointerType === 'mouse' && e.originalEvent['buttons'] == 1)) {
                var point = this._getContextPoint(e);
                point && this.signaturePainter.drawPath(this._context, point.x, point.y, this.lineColor(), this.lineWidth());
            }
        };
        this._pointerLeaveHandler = (e) => {
            this.signaturePainter.resetLastPosition();
        };
        this.format = (newVal) => {
            if (newVal)
                this.imagePainter.format(newVal);
            return this.imagePainter.format();
        };
        this.imageSizeMode = ko.observable(ImageSizeMode.Normal);
        this.imageAlignment = ko.observable(ImageAlignment.TopLeft);
        this.lineWidth = ko.observable(1);
        this.lineColor = ko.observable('#000000');
        this.zoom = options.zoom;
        this.image = ko.observable(options.imageSource);
        this.imageSizeMode(options.sizeMode);
        this.imageAlignment(options.alignment);
        this.imagePainter = new ImagePainter({
            alignment: this.imageAlignment,
            imageSource: this.image,
            sizeMode: this.imageSizeMode
        });
        this.format(options.imageType);
        this._disposables.push(this.signaturePainter = new SignaturePainter());
        this._disposables.push(this.signaturePainter.hasPoints.subscribe((newVal) => {
            if (newVal)
                this._setCanvasSize(this.initialSize.width, this.initialSize.height);
            else
                this._setCanvasSize(this.initialSize.width * this.zoom(), this.initialSize.height * this.zoom());
            this.refresh();
        }));
        this._disposables.push(this.scale = ko.computed(() => {
            return this.hasSignature() ? this.zoom() : 1;
        }));
        if (options.canDraw) {
            this._disposables.push((options.canDraw).subscribe((newValue) => {
                if (newValue) {
                    this._addEvents();
                }
                else {
                    this._removeEvents();
                }
            }));
        }
        this._disposables.push(this.zoom.subscribe((newVal) => {
            if (!this.signaturePainter.hasPoints()) {
                this._setCanvasSize(this.initialSize.width * newVal, this.initialSize.height * newVal);
                this.refresh();
            }
        }));
    }
    _getContextPoint(e) {
        if (e.target.nodeName !== 'CANVAS')
            return;
        var zoom = this.zoom();
        var x, y;
        if (e.offsetX && e.offsetY) {
            zoom = this.hasSignature() ? 1 : zoom;
            x = e.offsetX / zoom;
            y = e.offsetY / zoom;
        }
        else {
            var rect = this._context.canvas.getBoundingClientRect();
            x = (e.clientX - rect.left) / zoom;
            y = (e.clientY - rect.top) / zoom;
        }
        return { x, y };
    }
    _addEvents() {
        var element = this.$element.get(0);
        events.on(element, 'dxpointerdown', this._pointerDownHandler);
        events.on(element, 'dxpointermove', this._pointerMoveHandler);
        events.on(element, 'dxpointerleave', this._pointerLeaveHandler);
    }
    _removeEvents() {
        var element = this.$element.get(0);
        events.off(element, 'dxpointerdown', this._pointerDownHandler);
        events.off(element, 'dxpointermove', this._pointerMoveHandler);
        events.off(element, 'dxpointerleave', this._pointerLeaveHandler);
    }
    _setCanvasSize(width, height) {
        this._context.canvas.setAttribute('width', width);
        this._context.canvas.setAttribute('height', height);
    }
    _cleanCanvas() {
        this._context.clearRect(0, 0, this._context.canvas.width, this._context.canvas.height);
    }
    clear() {
        this.image(null);
        this.signaturePainter.reset();
        this._cleanCanvas();
    }
    refresh() {
        this._cleanCanvas();
        var zoom = this.signaturePainter.hasPoints() ? 1 : this.zoom();
        var size = this.signaturePainter.hasPoints() ? this.initialSize : undefined;
        this.imagePainter.refresh(this._context, zoom, size)
            .done(() => this.signaturePainter.refresh(this._context));
    }
    initSize(element, zoom) {
        this.$element = element;
        this.initialSize = {
            width: this.$element.outerWidth() / zoom,
            height: this.$element.outerHeight() / zoom
        };
    }
    initCanvas(element, zoom) {
        var canvas = this.$element.find('canvas')[0];
        this._context = canvas.getContext('2d');
        this._setCanvasSize(this.initialSize.width * zoom, this.initialSize.height * zoom);
        this.imagePainter.refresh(this._context, zoom, {
            width: this._context.canvas.offsetWidth,
            height: this._context.canvas.offsetHeight
        });
    }
    imageFormatByType(imageType) {
        return imageType === ImageEditingFieldViewModel.__DefaultImageType ? 'png' : imageType;
    }
    getImage() {
        return this._context.canvas.toDataURL('image/png');
    }
    hasSignature() {
        return this.signaturePainter.hasPoints();
    }
    dispose() {
        super.dispose();
        this._removeEvents();
        this.$element = null;
        this._context = null;
    }
    reset(initialImage, initialAlignment, initialSizeMode, initialImageType) {
        this.image(initialImage);
        this.imageAlignment(initialAlignment);
        this.imageSizeMode(initialSizeMode);
        this.format(this.imageFormatByType(initialImageType));
        this.signaturePainter.reset();
        this.refresh();
    }
}
ko.bindingHandlers['dxPainter'] = {
    init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        var options = (valueAccessor());
        $.fn.constructor(element).children().remove();
        var templateHtml = getTemplate('dx-painter');
        var $element = $.fn.constructor(element).append(templateHtml);
        var child = $element.children()[0];
        var $child = $.fn.constructor(child);
        var model = new Painter(options);
        model.initSize($child, options.zoom());
        addDisposeCallback(element, function () {
            model.dispose();
        });
        ko.applyBindings(model, child);
        model.initCanvas($child, options.zoom());
        return { controlsDescendantBindings: true };
    }
};
